---
title: "백준 1562 G1 계단 수"
toc: true
categories: []
tags: ["dp", "dp_bitmask"]
mathjax: true
date: 2025-06-04
---

# 접근

아예 접근을 못했다.

"계단 수"를 다시 엄밀하게 정의해 보면,
* 인접한 자릿수의 차이가 1인 수
* 길이가 $N$인 계단 수 중, 0~9 모든 숫자가 적어도 한 번은 등장해야 함
* 단, 0으로 시작하는 수는 안 됨

# DP 의 정의

3차원 배열을 사용하는 DP로 해결하며, DP를 잘 정의하는 것이 풀이의 핵심이다.

`dp`는 아래와 같이 정의한다.

```cpp{lineNos=false}
dp[length][last_digit][bitmask]
```

아래 3가지 정보로 상태를 정의한다.

* `length`는 현재 만드는 계단 수의 길이이다.
* `last_digit`은 현재 만드는 계단 수의 마지막 자리 숫자이다.
* ==`bitmask`는 0부터 9까지의 숫자 중 어떤 숫자들이 사용되었는지를 **비트 마스크**로 표현한 것이다.==

비트마스크로 0부터 9까지 총 10개의 숫자 중 어떤 것이 사용되었는지 확인해야 하므로, 총 10 비트가 필요하다.

예를 들어, `dp[4][5][0b00010 01110]`은, 
* 길이가 4인 계단 수 중에서,
* 마지막 숫자가 5이고,
* 등장한 숫자가 1, 2, 3, 5인
경우(상태)의 개수를 나타낸 것이다.

`length`는 $[1, 10^2]$ 범위이고, `last_digit`은 0부터 9까지 $10$개, `bitmask`는 총 10개 비트로 $2^{10} \approx 10^3 $개의 배열 공간이 필요하므로, 최악의 경우, 총 $10^2 \cdot 10 \cdot 10^3 = 10^6$ 개의 배열 요소가 필요하다.

배열 요소의 자료형을 `int`라고 하면, $10^6 \cdot 4$ 바이트, 즉 4MB가 필요하므로, 문제에서 제시한 메모리 제한 128MB 내에 해결할 수 있다.

{{<admo title="주의점">}}

여기서 중요한 점은, 문제에서 요구하는 **0부터 9까지의 모든 숫자가 등장해야 한다**라는 조건을 **DP를 설계할 때에는 일단 무시한다**는 점이다.

계단 수 조건(인접한 자리 수 차이가 1)은 DP 점화식에서 직접 관리하고, 숫자 등장 여부는 **비트마스크를 이용해 상태에 누적만 해둔다.**

이후, 모든 숫자가 등장했는지를 확인하는 작업은 마지막에 한 번만 수행하면 된다.
즉, `dp[N][0][0b11111 11111]`부터 `dp[N][9][0b11111 11111]`까지의 값을 모두 더해 정답을 구하면 된다.

{{</admo>}}

# 점화식

계단 수는 정의상 인접한 자리수의 차이가 엊ㅇ확히 1이어야 하므로, 현재 자리에 숫자 `digit`을 두기 위해선, 이전 자리 숫자가 `digit -1` 또는, `digit + 1`이어야 한다

```cpp{lineNos=false}
if (digit > 0) {
  dp[length][digit][new_mask] += dp[length - 1][digit - 1][prev_mask]
}
```

여기서 `prev_mask`는 길이 `length - 1` 짜리 계단 수에서 등장한 숫자들을 비트 마스크로 표현한 것이고, `new_mask = prev_mask | (1 << digit)`은 거기에 지금 추가하는 숫자 `digit`을 포함한 새로운 마스크이다.

중복된 숫자가 등장하여도 문제에서는 **"0 ~ 9 까지의 모든 숫자가 한 번 이상 등장"** 한다는 조건만 중요하므로, **이미 등장한 숫자를 다시 추가하는 것은 상관없다.**

위 조건문은 다음과 같은 의미이다.
* 현재 자리에 올 숫자 `digit`이 1 이상 일 때,
* 길이 `length - 1`이고 마지막 숫자가 `digit - 1` 이었던 계단 수들에서, `digit`을 붙여 길이 `length` 짜리 계단 수로 확장할 수 있다

예를 들어 길이가 5이고 마지막 숫자가 3인 계단 수를 만들고 싶다면, 길이 4이면서 마지막 숫자가 2였던 계단 수들로부터 올 수 있다.

하나 작은 곳에서부터 계단 수가 올 수 있다면, 높은 곳에서도 올 수 있다.

```cpp{lineNos=false}
if (digit < 9) {
  dp[length][digit][new_mask] += dp[length - 1][digit + 1][prev_mask]
}
```

위 조건문은 다음과 같은 의미이다.
* 현재 자리에 올 숫자 `digit`이 8 이하일 때,
* 길이 `legnth - 1`이고 마지막 숫자가 `digit + 1` 이었던 계단 수들에서, `digit`을 붙여 길이 `length`짜리 계단 수로 확장할 수 있다.

예를 들어 길이가 5이고 마지막 숫자가 3인 계단 수를 만들고 싶다면, 길이 4이면서 마지막 숫자가 4였던 계단 수들로부터 올 수 있다.


{{<admo>}}

종합하면, 길이가 5이고 마지막 숫자가 3인 계단 수는, 길이가 4면서 마지막 숫자가 2였던 계단 수들과, 4였던 계단 수들로부터 올 수 있다는 뜻이다.

{{</admo>}}

# 코드

전체 코드는 아래와 같다.

{{<hls source="assets/code.cc" syntax="cpp">}}